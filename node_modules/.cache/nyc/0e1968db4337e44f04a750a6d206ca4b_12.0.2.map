{"version":3,"file":"/Users/carlosbuendia/Documents/Projects/consensys/Frontier/clean/trl-api/src/services/resolvers/voters.ts","sources":["/Users/carlosbuendia/Documents/Projects/consensys/Frontier/clean/trl-api/src/services/resolvers/voters.ts"],"names":[],"mappings":"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","sourcesContent":["import { IFieldResolver, IResolvers } from 'graphql-tools';\nimport applyPagination from './util';\nconst _ = require('lodash')\nimport frontier from '../frontier';\n\nconst resolve = async (args: any, valueName: string, collection: any) => {\n  const filteredArgs = _.pickBy(args, _.negate(_.isUndefined));\n  const params = Object.entries(filteredArgs)[0];\n  let document = await collection.findOne(\n    { [`event.returnValues.${params[0]}`]: params[1].toString() },\n    { [`event.returnValues.${valueName}`]: 1 }\n  );\n\n  if (document === null) {\n    document = { event: { returnValues: { [valueName]: undefined } } };\n  }\n  return document.event.returnValues[valueName];\n};\n\ninterface IVotesArgs {\n  _voterAddress?: [string];\n  _tokensRemaining?: [number];\n  _tokensStaked?: [number];\n  _tokensUsed?: [number];\n  _periodIndex?: [number];\n  first?: number;\n  last?: number;\n}\n\nconst getResolver = async (votersCollection: any) => {\n  const voters: IFieldResolver<any, any> = async (obj, args: IVotesArgs) => {\n    const filteredArgs = _.pickBy(args, _.negate(_.isUndefined));\n\n    const document = await votersCollection.aggregate([\n      {\n        $match: filteredArgs._voterAddress ? { 'event.returnValues._whiteListedAccount': { $regex: filteredArgs._voterAddress, $options: 'i' } } : {}\n      },\n      {\n        $lookup: {\n          from: 'votes',\n          let: { localAddress: '$event.returnValues._whiteListedAccount' },\n          pipeline: [\n            {\n              $match:\n              {\n                $expr:\n                {\n                  $and:\n                    [\n                      { $eq: [`$event.returnValues._periodIndex`, filteredArgs._periodIndex] },\n                      { $eq: ['$event.returnValues._voterAddress', '$$localAddress'] }\n                    ]\n                }\n              }\n            }\n          ],\n          as: 'event.returnValues.voter_votes'\n        }\n      },\n      {\n        $project: {\n          _id: '$_id',\n          'event.returnValues._voterAddress': '$event.returnValues._whiteListedAccount',\n          'event.returnValues.voter_votes': 1,\n          'event.returnValues._tokensUsed': {\n            $cond: {\n              if: { $gt: [{ $size: '$event.returnValues.voter_votes' }, 0] },\n              then: { $sum: '$event.returnValues.voter_votes.event.returnValues._amount' },\n              else: 0\n            }\n          },\n          'event.returnValues._periodIndex': {\n            $sum: filteredArgs._periodIndex\n          }\n        }\n      },\n      { $sort: { 'event.returnValues._tokensUsed': -1 } }\n    ]).toArray();\n\n    return document.map((key: any) => key.event.returnValues);\n  };\n\n  const resolvers: IResolvers = {\n    Voter: {\n      _voterAddress: async (args: any) => {\n        if (args._voterAddress) return args._voterAddress;\n        return resolve(args, '_whiteListedAccount', votersCollection);\n      },\n      _tokensRemaining: async (args: any) => {\n        if (args._tokensRemaining) return args._tokensRemaining;\n        return (\n          frontier.contracts.TokenRankedList.votesBalance(\n            args._periodIndex,\n            args._whiteListedAccount\n          )\n        );\n      },\n      _tokensUsed: async (args: any) => {\n        if (_.isInteger(args._tokensUsed)) return args._tokensUsed;\n        return resolve(args, '_tokensUsed', votersCollection);\n      },\n      _tokensStaked: async (args: any) => {\n        if (args._tokensStaked) return args._tokensStaked;\n        const tokensRemaining = await frontier.contracts.TokenRankedList.votesBalance(\n          args._periodIndex,\n          args._voterAddress\n        );\n        return args._tokensUsed + tokensRemaining;\n      }\n    },\n\n    Query: {\n      voter(\n        obj,\n        {\n          _voterAddress,\n          _tokensRemaining,\n          _tokensStaked,\n          _tokensUsed,\n          _periodIndex\n        }\n      ) {\n        return {\n          _voterAddress,\n          _tokensRemaining,\n          _tokensStaked,\n          _tokensUsed,\n          _periodIndex\n        };\n      },\n      voters\n    }\n  };\n  return resolvers;\n};\n\nexport default getResolver;\n"]}